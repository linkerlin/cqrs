<!DOCTYPE html><html lang="zh-CN"><head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CQRS架构调研报告：linkerlin/cqrs项目分析</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&amp;family=Inter:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary: #0f766e;
            --primary-light: #14b8a6;
            --accent: #f59e0b;
            --neutral: #374151;
            --neutral-light: #9ca3af;
            --bg-primary: #fafaf9;
            --bg-secondary: #f4f4f5;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #fafaf9 0%, #f4f4f5 100%);
            color: var(--neutral);
            line-height: 1.7;
        }
        
        .serif {
            font-family: 'Playfair Display', serif;
        }
        
        .toc-fixed {
            position: fixed;
            top: 0;
            left: 0;
            width: 280px;
            height: 100vh;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid #e5e7eb;
            z-index: 1000;
            overflow-y: auto;
            padding: 2rem 1.5rem;
        }
        
        .main-content {
            margin-left: 280px;
            min-height: 100vh;
        }
        
        .hero-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            align-items: center;
            min-height: 60vh;
        }
        
        .citation {
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
            border-bottom: 1px dotted var(--primary);
            transition: all 0.3s ease;
        }
        
        .citation:hover {
            background: rgba(15, 118, 110, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        .section-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            padding: 2.5rem;
            margin-bottom: 2rem;
            border-left: 4px solid var(--primary);
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-left: 4px solid var(--accent);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }
        
        .tech-badge {
            display: inline-block;
            background: var(--primary-light);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
            margin: 0.25rem;
        }
        
        .toc-link {
            display: block;
            padding: 0.5rem 0;
            color: var(--neutral);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: all 0.3s ease;
        }
        
        .toc-link:hover {
            color: var(--primary);
            border-bottom-color: var(--primary-light);
            padding-left: 0.5rem;
        }
        
        .toc-link.active {
            color: var(--primary);
            font-weight: 600;
        }
        
        .diagram-container {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }
        
        /* Mermaid Chart Styles */
        .mermaid-container {
            display: flex;
            justify-content: center;
            min-height: 300px;
            max-height: 800px;
            background: #ffffff;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            position: relative;
            overflow: hidden;
        }
        
        .mermaid-container .mermaid {
            width: 100%;
            max-width: 100%;
            height: 100%;
            cursor: grab;
            transition: transform 0.3s ease;
            transform-origin: center center;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .mermaid-container .mermaid svg {
            max-width: 100%;
            height: 100%;
            display: block;
            margin: 0 auto;
        }
        
        .mermaid-container .mermaid:active {
            cursor: grabbing;
        }
        
        .mermaid-container.zoomed .mermaid {
            height: 100%;
            width: 100%;
            cursor: grab;
        }
        
        .mermaid-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 20;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .mermaid-control-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #374151;
            font-size: 14px;
            min-width: 36px;
            height: 36px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .mermaid-control-btn:hover {
            background: #f8fafc;
            border-color: #3b82f6;
            color: #3b82f6;
            transform: translateY(-1px);
        }
        
        .mermaid-control-btn:active {
            transform: scale(0.95);
        }
        
        @media (max-width: 1024px) {
            .toc-fixed {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 1000;
            }
            
            .toc-fixed.open {
                transform: translateX(0);
                box-shadow: 0 0 20px rgba(0,0,0,0.2);
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .hero-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            /* Responsive Mermaid Controls */
            .mermaid-control-btn:not(.reset-zoom) {
                display: none;
            }
            .mermaid-controls {
                top: auto;
                bottom: 15px;
                right: 15px;
            }
        }

        /* Prevent horizontal overflow on small screens */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
            }
        }

        /* Adjust hero section for small screens */
        @media (max-width: 640px) {
            .hero-grid {
                padding: 1rem;
            }
            
            .hero-grid h1 {
                font-size: 2.25rem;
                line-height: 2.5rem;
            }
            
            .hero-grid p {
                font-size: 1rem;
            }
        }
    </style>
  </head>

  <body>
    <!-- Table of Contents -->
    <nav class="toc-fixed">
      <div class="mb-8">
        <h3 class="serif text-xl font-bold text-gray-800 mb-4">目录</h3>
        <div class="space-y-1">
          <a href="#overview" class="toc-link">项目概述</a>
          <a href="#cqrs-principles" class="toc-link">CQRS基本原理</a>
          <a href="#implementation" class="toc-link">项目实现细节</a>
          <a href="#redis-communication" class="toc-link">Redis双向通讯</a>
          <a href="#query-flow" class="toc-link">查询流程解析</a>
          <a href="#command-flow" class="toc-link">命令流程解析</a>
          <a href="#cache-refactoring" class="toc-link">缓存处理改款</a>
          <a href="#avoiding-duplication" class="toc-link">避免重复写入</a>
        </div>
      </div>

      <div class="mt-8 pt-8 border-t border-gray-200">
        <h4 class="font-semibold text-gray-700 mb-3">技术栈</h4>
        <div class="flex flex-wrap">
          <span class="tech-badge">React 18</span>
          <span class="tech-badge">TypeScript</span>
          <span class="tech-badge">NestJS</span>
          <span class="tech-badge">Redis</span>
        </div>
      </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Hero Section -->
      <section class="px-8 py-12 bg-gradient-to-br from-teal-50 to-amber-50">
        <div class="max-w-6xl mx-auto">
          <div class="hero-grid">
            <div>
              <h1 class="serif text-5xl font-bold text-gray-900 mb-6 leading-tight">
                <em class="text-teal-700">CQRS架构调研报告</em>
                <br/>
                linkerlin/cqrs项目分析
              </h1>
              <p class="text-xl text-gray-600 leading-relaxed">
                基于Redis List实现双向消息通讯的全栈CMS框架，通过Job层统一处理缓存填充实现更彻底的职责分离
              </p>
            </div>
            <div class="relative">
              <img src="https://kimi-web-img.moonshot.cn/img/ucc.alicdn.com/693ca0b50ff72ec04b6d76787d9339c7201b2125.png" alt="CQRS架构抽象设计图" class="w-full h-80 object-cover rounded-2xl shadow-2xl" size="medium" aspect="wide" query="CQRS架构设计" referrerpolicy="no-referrer" data-modified="1" data-score="11599.00"/>
              <div class="absolute inset-0 bg-gradient-to-tr from-teal-900/20 to-transparent rounded-2xl"></div>
            </div>
          </div>

          <!-- Key Highlights -->
          <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mt-12">
            <div class="bg-white/80 backdrop-blur-sm rounded-xl p-6 border border-teal-200">
              <div class="text-teal-600 text-2xl mb-3">
                <i class="fas fa-code-branch"></i>
              </div>
              <h3 class="font-semibold text-gray-800 mb-2">职责分离</h3>
              <p class="text-gray-600 text-sm">命令与查询彻底分离，Service层不包含任何写缓存代码</p>
            </div>
            <div class="bg-white/80 backdrop-blur-sm rounded-xl p-6 border border-amber-200">
              <div class="text-amber-600 text-2xl mb-3">
                <i class="fas fa-exchange-alt"></i>
              </div>
              <h3 class="font-semibold text-gray-800 mb-2">双向通讯</h3>
              <p class="text-gray-600 text-sm">基于Redis List实现Service与Job层的高效异步通信</p>
            </div>
            <div class="bg-white/80 backdrop-blur-sm rounded-xl p-6 border border-emerald-200">
              <div class="text-emerald-600 text-2xl mb-3">
                <i class="fas fa-memory"></i>
              </div>
              <h3 class="font-semibold text-gray-800 mb-2">统一缓存管理</h3>
              <p class="text-gray-600 text-sm">Job层统一负责缓存写入，避免代码重复和维护复杂性</p>
            </div>
          </div>
        </div>
      </section>

      <!-- Content Sections -->
      <div class="max-w-4xl mx-auto px-8 py-12">

        <!-- Project Overview -->
        <section id="overview" class="section-card">
          <h2 class="serif text-3xl font-bold text-gray-900 mb-6">项目概述</h2>
          <p class="text-lg text-gray-700 mb-6">
            <strong>linkerlin/cqrs项目是一个基于CQRS架构的全栈内容管理系统（CMS）框架</strong>
            <a href="https://github.com/linkerlin/cqrs" class="citation">[44]</a>。
            该项目旨在提供一个实践CQRS设计模式的示例，并展示了如何利用现代技术栈构建一个解耦的、可扩展的应用程序。
          </p>

          <div class="highlight-box">
            <h4 class="font-semibold text-gray-800 mb-3">
              <i class="fas fa-lightbulb text-amber-600 mr-2"></i>
              核心创新
            </h4>
            <p class="text-gray-700">
              该项目通过将缓存填充任务完全交由Job层处理，使得Service层无需包含任何写缓存的代码，
              从而实现了更彻底的职责分离。同时利用Redis List实现了双向消息通讯机制。
            </p>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
            <div>
              <h4 class="font-semibold text-gray-800 mb-4">前端技术栈</h4>
              <div class="space-y-2">
                <div class="flex items-center">
                  <span class="tech-badge">React 18</span>
                  <span class="ml-2 text-gray-600">UI渲染与组件化</span>
                </div>
                <div class="flex items-center">
                  <span class="tech-badge">TypeScript</span>
                  <span class="ml-2 text-gray-600">类型安全与维护性</span>
                </div>
                <div class="flex items-center">
                  <span class="tech-badge">Vite</span>
                  <span class="ml-2 text-gray-600">快速构建工具</span>
                </div>
                <div class="flex items-center">
                  <span class="tech-badge">Tailwind CSS</span>
                  <span class="ml-2 text-gray-600">实用优先CSS框架</span>
                </div>
              </div>
            </div>
            <div>
              <h4 class="font-semibold text-gray-800 mb-4">后端技术栈</h4>
              <div class="space-y-2">
                <div class="flex items-center">
                  <span class="tech-badge">NestJS</span>
                  <span class="ml-2 text-gray-600">高效Node.js框架</span>
                </div>
                <div class="flex items-center">
                  <span class="tech-badge">TypeScript</span>
                  <span class="ml-2 text-gray-600">统一类型系统</span>
                </div>
                <div class="flex items-center">
                  <span class="tech-badge">Redis</span>
                  <span class="ml-2 text-gray-600">消息队列与缓存</span>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- CQRS Principles -->
        <section id="cqrs-principles" class="section-card">
          <h2 class="serif text-3xl font-bold text-gray-900 mb-6">CQRS架构基本原理与核心概念</h2>

          <div class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">CQRS模式定义</h3>
            <p class="text-gray-700 mb-4">
              <strong>命令查询职责分离（Command Query Responsibility Segregation, CQRS）</strong>是一种软件架构模式，
              其核心思想在于将应用程序的数据读取操作（查询，Query）和数据修改操作（命令，Command）分离开来，
              使用不同的模型进行处理<a href="https://learn.microsoft.com/zh-cn/azure/architecture/patterns/cqrs" class="citation">[1]</a>
              <a href="https://medium.com/brobridge/%E6%B7%BA%E8%AB%87-cqrs-%E5%AF%A6%E7%8F%BE%E6%96%B9%E6%B3%95-3b4fcb8d5c86" class="citation">[2]</a>。
            </p>

            <div class="diagram-container">
              <h4 class="font-semibold text-gray-800 mb-4 text-center">CQRS架构模式</h4>
              <div class="mermaid-container">
                <div class="mermaid-controls">
                  <button class="mermaid-control-btn zoom-in" title="放大">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button class="mermaid-control-btn zoom-out" title="缩小">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button class="mermaid-control-btn reset-zoom" title="重置">
                    <i class="fas fa-expand-arrows-alt"></i>
                  </button>
                  <button class="mermaid-control-btn fullscreen" title="全屏查看">
                    <i class="fas fa-expand"></i>
                  </button>
                </div>
                <div class="mermaid">
                  graph LR
                  A[&#34;Client&#34;] --&gt; B[&#34;Command Model&#34;]
                  A --&gt; C[&#34;Query Model&#34;]
                  B --&gt; D[&#34;Write Database&#34;]
                  C --&gt; E[&#34;Read Database&#34;]
                  D --&gt; F[&#34;Event Bus&#34;]
                  F --&gt; G[&#34;Read Model Update&#34;]

                  style A fill:#e1f5fe,stroke:#0f766e,stroke-width:2px,color:#0f766e
                  style B fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style C fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                  style D fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style E fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                  style F fill:#f3e8ff,stroke:#8b5cf6,stroke-width:2px,color:#374151
                  style G fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                </div>
              </div>
            </div>

            <p class="text-gray-700">
              这种分离借鉴了Bertrand Meyer提出的&#34;命令查询分离&#34;（Command-Query Separation, CQS）原则，
              CQS主要应用于对象设计层面，而CQRS将这一思想提升到系统架构层面
              <a href="https://colobu.com/2015/07/24/brief-history-scaling-linkedin/" class="citation">[12]</a>。
            </p>
          </div>

          <div class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">核心原则：命令与查询职责分离</h3>
            <p class="text-gray-700 mb-4">
              <strong>CQRS架构的核心原则在于严格区分命令（Command）和查询（Query）的职责。</strong>
              命令是指那些会改变系统状态的操作，例如创建订单、更新用户信息、删除商品等。
              查询则是指那些不会改变系统状态，仅用于获取数据的操作。
            </p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="bg-red-50 border-l-4 border-red-400 p-4 rounded">
                <h4 class="font-semibold text-red-800 mb-2">
                  <i class="fas fa-edit mr-2"></i>命令（Command）
                </h4>
                <ul class="text-red-700 text-sm space-y-1">
                  <li>• 改变系统状态</li>
                  <li>• 包含业务逻辑校验</li>
                  <li>• 不直接返回数据</li>
                  <li>• 关注数据一致性</li>
                </ul>
              </div>
              <div class="bg-green-50 border-l-4 border-green-400 p-4 rounded">
                <h4 class="font-semibold text-green-800 mb-2">
                  <i class="fas fa-search mr-2"></i>查询（Query）
                </h4>
                <ul class="text-green-700 text-sm space-y-1">
                  <li>• 不改变系统状态</li>
                  <li>• 仅用于获取数据</li>
                  <li>• 应简单高效</li>
                  <li>• 关注查询性能</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">读写模型分离</h3>
            <p class="text-gray-700 mb-4">
              在CQRS架构中，读写模型的分离是其核心特征之一。这意味着系统至少包含两个独立的数据模型：
              一个用于处理写操作（命令模型），另一个用于处理读操作（查询模型）
              <a href="https://learn.microsoft.com/zh-cn/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns" class="citation">[15]</a>
              <a href="https://medium.com/marklin-hehe/day-26-cqrs-command-query-responsibility-segregation-42efdc7fb715" class="citation">[16]</a>。
            </p>

            <div class="highlight-box">
              <h4 class="font-semibold text-gray-800 mb-3">读写模型分离的优势</h4>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <h5 class="font-medium text-gray-800 mb-2">命令模型特点：</h5>
                  <ul class="text-gray-700 text-sm space-y-1">
                    <li>• 面向领域模型设计</li>
                    <li>• 包含复杂业务逻辑</li>
                    <li>• 确保数据一致性</li>
                    <li>• 采用DDD聚合根概念</li>
                  </ul>
                </div>
                <div>
                  <h5 class="font-medium text-gray-800 mb-2">查询模型特点：</h5>
                  <ul class="text-gray-700 text-sm space-y-1">
                    <li>• 面向展示需求优化</li>
                    <li>• 高度非规范化结构</li>
                    <li>• 物化视图定制</li>
                    <li>• 优化查询效率</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div>
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">优势与考量</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="bg-teal-50 border-l-4 border-teal-400 p-4 rounded">
                <h4 class="font-semibold text-teal-800 mb-3">
                  <i class="fas fa-check-circle mr-2"></i>主要优势
                </h4>
                <ul class="text-teal-700 text-sm space-y-2">
                  <li>• <strong>性能提升</strong>：读写操作独立优化和扩展<a href="https://exatosoftware.com/exploring-the-command-query-responsibility-segregation-cqrs-pattern-in-software-architecture/" class="citation">[27]</a>
                  </li>
                  <li>• <strong>灵活性增强</strong>：不同模型可采用不同技术栈<a href="https://solutionsarchitecture.medium.com/cqrs-a-deep-dive-into-command-query-responsibility-segregation-4fd83d79f756" class="citation">[30]</a>
                  </li>
                  <li>• <strong>关注点分离</strong>：提高开发效率和可维护性<a href="https://www.techtarget.com/searchapparchitecture/definition/CQRS-command-query-responsibility-segregation" class="citation">[32]</a>
                  </li>
                  <li>• <strong>安全性控制</strong>：更精细的访问权限管理<a href="https://vikasg11.medium.com/cqrs-architecture-pattern-a-holistic-view-e6e17172e5c7" class="citation">[33]</a>
                  </li>
                </ul>
              </div>
              <div class="bg-amber-50 border-l-4 border-amber-400 p-4 rounded">
                <h4 class="font-semibold text-amber-800 mb-3">
                  <i class="fas fa-exclamation-triangle mr-2"></i>实施考量
                </h4>
                <ul class="text-amber-700 text-sm space-y-2">
                  <li>• <strong>复杂度增加</strong>：需处理独立模型和同步机制<a href="https://medium.com/@khanjani.hamid/part-1-understanding-cqrs-concepts-and-fundamentals-9060833aeb11" class="citation">[37]</a>
                  </li>
                  <li>• <strong>最终一致性</strong>：读模型可能存在延迟<a href="https://kalele.io/really-simple-cqrs/" class="citation">[39]</a>
                  </li>
                  <li>• <strong>数据冗余</strong>：增加存储成本和同步开销</li>
                  <li>• <strong>适用场景</strong>：更适合复杂业务系统<a href="https://www.baeldung.com/cqrs-event-sourcing-java" class="citation">[42]</a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>

        <!-- Implementation Details -->
        <section id="implementation" class="section-card">
          <h2 class="serif text-3xl font-bold text-gray-900 mb-6">linkerlin/cqrs项目实现细节</h2>

          <div id="redis-communication" class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">核心架构特点：基于Redis List的双向消息通讯</h3>
            <p class="text-gray-700 mb-4">
              <strong>linkerlin/cqrs项目在CQRS架构的实现上，其核心创新点在于利用Redis List数据结构实现了双向消息通讯机制</strong>
              <a href="https://learn.microsoft.com/zh-cn/azure/architecture/patterns/cqrs" class="citation">[48]</a>。
              这一设计选择对于理解项目的整体架构至关重要。
            </p>

            <div class="diagram-container">
              <h4 class="font-semibold text-gray-800 mb-4 text-center">Redis List双向通讯机制</h4>
              <div class="mermaid-container">
                <div class="mermaid-controls">
                  <button class="mermaid-control-btn zoom-in" title="放大">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button class="mermaid-control-btn zoom-out" title="缩小">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button class="mermaid-control-btn reset-zoom" title="重置">
                    <i class="fas fa-expand-arrows-alt"></i>
                  </button>
                  <button class="mermaid-control-btn fullscreen" title="全屏查看">
                    <i class="fas fa-expand"></i>
                  </button>
                </div>
                <div class="mermaid">
                  sequenceDiagram
                  participant Client
                  participant Service
                  participant RedisList
                  participant Job

                  Client-&gt;&gt;Service: HTTP请求（查询/命令）
                  alt 查询请求
                  Service-&gt;&gt;Redis: 检查缓存
                  Redis--&gt;&gt;Service: 缓存命中/未命中
                  end

                  alt 缓存未命中或命令请求
                  Service-&gt;&gt;RedisList: LPUSH 任务消息
                  RedisList-&gt;&gt;Job: BRPOP 获取任务
                  Job-&gt;&gt;Database: 执行业务逻辑
                  Job-&gt;&gt;Redis: 更新缓存
                  Job-&gt;&gt;RedisList: 返回处理结果
                  RedisList-&gt;&gt;Service: 获取结果
                  end

                  Service-&gt;&gt;Client: HTTP响应
                </div>
              </div>
            </div>

            <div class="bg-blue-50 border-l-4 border-blue-400 p-4 rounded mt-6">
              <h4 class="font-semibold text-blue-800 mb-3">Redis List特性利用</h4>
              <p class="text-blue-700 text-sm mb-2">
                Redis List是一个简单的字符串列表，按照插入顺序排序，支持在列表的两端进行高效的插入和删除操作。
              </p>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <h5 class="font-medium text-blue-800 mb-2">主要操作命令：</h5>
                  <ul class="text-blue-700 text-xs space-y-1">
                    <li>•
                      <code>LPUSH</code>：左端插入
                    </li>
                    <li>•
                      <code>RPUSH</code>：右端插入
                    </li>
                    <li>•
                      <code>LPOP</code>：左端弹出
                    </li>
                    <li>•
                      <code>RPOP</code>：右端弹出
                    </li>
                    <li>•
                      <code>BRPOP</code>：阻塞式右端弹出
                    </li>
                  </ul>
                </div>
                <div>
                  <h5 class="font-medium text-blue-800 mb-2">实现优势：</h5>
                  <ul class="text-blue-700 text-xs space-y-1">
                    <li>• 轻量级消息队列</li>
                    <li>• 高性能和持久化</li>
                    <li>• 内置阻塞弹出支持</li>
                    <li>• 无需额外中间件</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div id="query-flow" class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">查询（Query）流程解析</h3>
            <p class="text-gray-700 mb-4">
              在linkerlin/cqrs项目中，<strong>查询流程的设计充分体现了CQRS架构的核心思想，即优化读取操作</strong>
              <a href="https://medium.com/@90mandalchandan/cqrs-architecture-how-it-works-5f18a36886ea" class="citation">[49]</a>。
            </p>

            <div class="diagram-container">
              <h4 class="font-semibold text-gray-800 mb-4 text-center">查询流程时序图</h4>
              <div class="mermaid-container">
                <div class="mermaid-controls">
                  <button class="mermaid-control-btn zoom-in" title="放大">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button class="mermaid-control-btn zoom-out" title="缩小">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button class="mermaid-control-btn reset-zoom" title="重置">
                    <i class="fas fa-expand-arrows-alt"></i>
                  </button>
                  <button class="mermaid-control-btn fullscreen" title="全屏查看">
                    <i class="fas fa-expand"></i>
                  </button>
                </div>
                <div class="mermaid">
                  graph TD
                  A[&#34;HTTP请求&#34;] --&gt; B{&#34;判断请求类型&#34;}
                  B --&gt;|&#34;查询请求&#34;| C[&#34;检查Redis缓存&#34;]
                  C --&gt; D{&#34;缓存命中?&#34;}
                  D --&gt;|&#34;是&#34;| E[&#34;直接返回缓存数据&#34;]
                  D --&gt;|&#34;否&#34;| F[&#34;创建缓存填充任务&#34;]
                  F --&gt; G[&#34;LPUSH到Redis List&#34;]
                  G --&gt; H[&#34;BRPOP获取任务&#34;]
                  H --&gt; I[&#34;执行数据库查询&#34;]
                  I --&gt; J[&#34;写入Redis缓存&#34;]
                  J --&gt; K[&#34;返回处理结果&#34;]
                  K --&gt; E

                  style A fill:#e1f5fe,stroke:#0f766e,stroke-width:2px,color:#0f766e
                  style B fill:#f3f4f6,stroke:#374151,stroke-width:2px,color:#374151
                  style C fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                  style D fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style E fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                  style F fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style G fill:#fbbf24,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style H fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style I fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#374151
                  style J fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#374151
                  style K fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                </div>
              </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
              <div class="bg-green-50 border-l-4 border-green-400 p-4 rounded">
                <h4 class="font-semibold text-green-800 mb-3">
                  <i class="fas fa-check-circle mr-2"></i>缓存命中（Cache Hit）
                </h4>
                <p class="text-green-700 text-sm mb-2">
                  如果Redis缓存中存在请求的数据，Service层会直接将缓存数据返回给前端。
                </p>
                <ul class="text-green-700 text-xs space-y-1">
                  <li>• 避免数据库查询</li>
                  <li>• 显著提升响应速度</li>
                  <li>• 减轻数据库压力</li>
                  <li>• 提高系统吞吐量</li>
                </ul>
              </div>
              <div class="bg-orange-50 border-l-4 border-orange-400 p-4 rounded">
                <h4 class="font-semibold text-orange-800 mb-3">
                  <i class="fas fa-clock mr-2"></i>缓存未命中（Cache Miss）
                </h4>
                <p class="text-orange-700 text-sm mb-2">
                  如果缓存中不存在数据，Service层将查询请求以JSON格式推入Redis List。
                </p>
                <ul class="text-orange-700 text-xs space-y-1">
                  <li>• Job层通过BRPOP消费任务</li>
                  <li>• 执行实际数据库查询</li>
                  <li>• 将数据写入Redis缓存</li>
                  <li>• 异步化处理机制</li>
                </ul>
              </div>
            </div>
          </div>

          <div id="command-flow" class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">命令（Command）流程解析</h3>
            <p class="text-gray-700 mb-4">
              在linkerlin/cqrs项目中，<strong>命令流程负责处理那些会改变系统状态的操作，例如创建、更新或删除数据</strong>
              <a href="https://shiftasia.com/community/microservices-with-cqrs-and-event-sourcing-part1/" class="citation">[51]</a>。
            </p>

            <div class="bg-gray-50 border-l-4 border-gray-400 p-4 rounded mt-6">
              <h4 class="font-semibold text-gray-800 mb-3">命令处理流程</h4>
              <ol class="text-gray-700 text-sm space-y-2">
                <li>1. <strong>Service层接收HTTP请求</strong>：识别为命令请求</li>
                <li>2. <strong>命令序列化</strong>：将命令数据转换为JSON格式</li>
                <li>3. <strong>推入命令队列</strong>：使用LPUSH将命令发送到Redis List</li>
                <li>4. <strong>Job层监听</strong>：通过BRPOP阻塞获取命令</li>
                <li>5. <strong>命令处理</strong>：执行相应的业务逻辑</li>
                <li>6. <strong>结果返回</strong>：将处理结果推送到返回队列</li>
                <li>7. <strong>缓存更新</strong>：根据小改款设计更新缓存</li>
              </ol>
            </div>
          </div>

          <div>
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">Service层与Job层的职责与协作</h3>
            <p class="text-gray-700 mb-4">
              在linkerlin/cqrs项目中，<strong>Service层和Job层各自承担着清晰的职责，并通过Redis List实现高效的协作</strong>
              <a href="https://threedots.tech/post/basic-cqrs-in-go/" class="citation">[52]</a>。
            </p>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="bg-blue-50 border-l-4 border-blue-400 p-4 rounded">
                <h4 class="font-semibold text-blue-800 mb-3">
                  <i class="fas fa-server mr-2"></i>Service层职责
                </h4>
                <ul class="text-blue-700 text-sm space-y-2">
                  <li>• <strong>接收HTTP请求</strong>：作为系统入口点</li>
                  <li>• <strong>处理缓存命中查询</strong>：直接返回缓存数据</li>
                  <li>• <strong>触发命令处理</strong>：将请求转为任务推入队列<a href="https://dzone.com/articles/concepts-of-cqrs" class="citation">[53]</a>
                  </li>
                  <li>• <strong>响应处理结果</strong>：接收Job层返回结果</li>
                </ul>
              </div>
              <div class="bg-purple-50 border-l-4 border-purple-400 p-4 rounded">
                <h4 class="font-semibold text-purple-800 mb-3">
                  <i class="fas fa-cogs mr-2"></i>Job层职责
                </h4>
                <ul class="text-purple-700 text-sm space-y-2">
                  <li>• <strong>监听命令队列</strong>：通过BRPOP获取任务</li>
                  <li>• <strong>执行业务逻辑</strong>：处理数据库读写操作</li>
                  <li>• <strong>填充更新缓存</strong>：负责缓存写入操作<a href="https://www.bilibili.com/read/cv25657040/" class="citation">[54]</a>
                  </li>
                  <li>• <strong>返回处理结果</strong>：将结果推送到返回队列</li>
                </ul>
              </div>
            </div>

            <div class="highlight-box mt-6">
              <h4 class="font-semibold text-gray-800 mb-3">协作模式特点</h4>
              <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <h5 class="font-medium text-gray-800 mb-2">异步处理</h5>
                  <p class="text-gray-700 text-sm">基于消息队列实现松耦合通信</p>
                </div>
                <div>
                  <h5 class="font-medium text-gray-800 mb-2">独立扩展</h5>
                  <p class="text-gray-700 text-sm">各层可根据负载情况独立扩展</p>
                </div>
                <div>
                  <h5 class="font-medium text-gray-800 mb-2">职责分离</h5>
                  <p class="text-gray-700 text-sm">Service层轻量响应，Job层专注处理</p>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Cache Refactoring -->
        <section id="cache-refactoring" class="section-card">
          <h2 class="serif text-3xl font-bold text-gray-900 mb-6">缓存处理小改款设计与实现</h2>

          <div class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">改款背景：Service层与缓存写入职责分离</h3>
            <p class="text-gray-700 mb-4">
              在传统的CQRS架构实现中，Service层在处理查询请求时，如果遇到缓存未命中（Cache Miss）的情况，
              通常的作法是Service层自身负责从数据库加载数据并写入缓存。这种设计虽然直观，但也存在一些固有的问题。
            </p>

            <div class="bg-red-50 border-l-4 border-red-400 p-4 rounded mb-6">
              <h4 class="font-semibold text-red-800 mb-3">
                <i class="fas fa-exclamation-triangle mr-2"></i>传统设计问题
              </h4>
              <ul class="text-red-700 text-sm space-y-2">
                <li>• <strong>违反单一职责原则</strong>：Service层职责不够纯粹</li>
                <li>• <strong>代码复杂度增加</strong>：包含缓存维护和更新逻辑</li>
                <li>• <strong>维护困难</strong>：缓存策略变更影响Service层</li>
                <li>• <strong>测试复杂性</strong>：需要模拟缓存操作</li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4 class="font-semibold text-gray-800 mb-3">小改款核心目标</h4>
              <p class="text-gray-700">
                <strong>将缓存填充的职责从Service层中剥离出来，使得Service层不再包含任何直接写入缓存的代码</strong>
                <a href="https://blog.csdn.net/weixin_37871026/article/details/123084372" class="citation">[55]</a>。
                这种职责的进一步分离，使得系统架构更加清晰，各个组件的边界更加明确。
              </p>
            </div>
          </div>

          <div class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">设计思路：Cache Miss后数据填充任务交由Job处理</h3>
            <p class="text-gray-700 mb-4">
              基于将缓存写入职责从Service层剥离的背景，<strong>linkerlin/cqrs项目的小改款提出了一个明确的设计思路：
                当Service层在处理查询请求时发生缓存未命中（Cache Miss），不再由Service层自身去数据库加载数据并写入缓存，
                而是将这个&#34;数据填充缓存&#34;的任务交给独立的Job来处理</strong>
              <a href="https://time.geekbang.org/column/article/150881" class="citation">[56]</a>。
            </p>

            <div class="diagram-container">
              <h4 class="font-semibold text-gray-800 mb-4 text-center">缓存处理小改款设计</h4>
              <div class="mermaid-container">
                <div class="mermaid-controls">
                  <button class="mermaid-control-btn zoom-in" title="放大">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button class="mermaid-control-btn zoom-out" title="缩小">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button class="mermaid-control-btn reset-zoom" title="重置">
                    <i class="fas fa-expand-arrows-alt"></i>
                  </button>
                  <button class="mermaid-control-btn fullscreen" title="全屏查看">
                    <i class="fas fa-expand"></i>
                  </button>
                </div>
                <div class="mermaid">
                  graph LR
                  A[&#34;Service层&#34;] --&gt; B{&#34;缓存检查&#34;}
                  B --&gt;|&#34;命中&#34;| C[&#34;直接返回&#34;]
                  B --&gt;|&#34;未命中&#34;| D[&#34;创建缓存填充任务&#34;]
                  D --&gt; E[&#34;Redis List&#34;]
                  E --&gt; F[&#34;Job层&#34;]
                  F --&gt; G[&#34;执行数据库查询&#34;]
                  G --&gt; H[&#34;写入Redis缓存&#34;]

                  style A fill:#e1f5fe,stroke:#0f766e,stroke-width:2px,color:#0f766e
                  style B fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style C fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                  style D fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#374151
                  style E fill:#fbbf24,stroke:#f59e0b,stroke-width:2px,color:#374151
                  style F fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#374151
                  style G fill:#fed7aa,stroke:#f97316,stroke-width:2px,color:#374151
                  style H fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                </div>
              </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
              <div class="bg-green-50 border-l-4 border-green-400 p-4 rounded">
                <h4 class="font-semibold text-green-800 mb-3">
                  <i class="fas fa-check-circle mr-2"></i>设计优势
                </h4>
                <ul class="text-green-700 text-sm space-y-2">
                  <li>• <strong>严格遵循CQRS</strong>：命令查询彻底分离</li>
                  <li>• <strong>Service层简化</strong>：只读缓存，触发任务</li>
                  <li>• <strong>Job层专业化</strong>：专注数据加载和缓存更新</li>
                  <li>• <strong>架构更清晰</strong>：组件边界明确</li>
                </ul>
              </div>
              <div class="bg-blue-50 border-l-4 border-blue-400 p-4 rounded">
                <h4 class="font-semibold text-blue-800 mb-3">
                  <i class="fas fa-cog mr-2"></i>实现特点
                </h4>
                <ul class="text-blue-700 text-sm space-y-2">
                  <li>• <strong>异步处理</strong>：提高系统并发能力</li>
                  <li>• <strong>集中管理</strong>：缓存策略统一控制</li>
                  <li>• <strong>独立演进</strong>：Job层可独立优化</li>
                  <li>• <strong>易于扩展</strong>：支持复杂缓存策略</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="mb-8">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">实现方式</h3>

            <div class="mb-6">
              <h4 class="text-xl font-semibold text-gray-800 mb-4">利用现有消息队列机制</h4>
              <p class="text-gray-700 mb-4">
                <strong>linkerlin/cqrs项目中小改款的实现，巧妙地利用了项目中已有的基于Redis List实现的消息队列机制</strong>
                <a href="https://www.jdon.com/63108.html" class="citation">[57]</a>。
                这个机制原本用于在Service层和Job层之间传递命令和处理结果，现在被扩展用于传递缓存填充任务。
              </p>

              <div class="bg-gray-50 border-l-4 border-gray-400 p-4 rounded">
                <h5 class="font-semibold text-gray-800 mb-3">消息队列机制特点</h5>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h6 class="font-medium text-gray-800 mb-2">消息传递流程：</h6>
                    <ol class="text-gray-700 text-xs space-y-1">
                      <li>1. Service层LPUSH推送任务</li>
                      <li>2. Job层BRPOP获取任务</li>
                      <li>3. 异步处理不阻塞Service</li>
                      <li>4. FIFO顺序保证</li>
                    </ol>
                  </div>
                  <div>
                    <h6 class="font-medium text-gray-800 mb-2">技术优势：</h6>
                    <ul class="text-gray-700 text-xs space-y-1">
                      <li>• 避免引入新中间件</li>
                      <li>• 简化系统架构</li>
                      <li>• 利用Redis高性能</li>
                      <li>• 内置持久化支持</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="bg-teal-50 border-l-4 border-teal-400 p-4 rounded">
                <h4 class="font-semibold text-teal-800 mb-3">
                  <i class="fas fa-play mr-2"></i>Service层：触发缓存填充任务
                </h4>
                <p class="text-teal-700 text-sm mb-3">
                  <strong>Service层在缓存处理方面的职责被显著简化，其核心任务是触发缓存填充任务</strong>
                  <a href="https://blog.csdn.net/weixin_44409190/article/details/142989869" class="citation">[58]</a>。
                </p>
                <ul class="text-teal-700 text-xs space-y-1">
                  <li>• 检查缓存是否存在</li>
                  <li>• 构造缓存填充命令</li>
                  <li>• 推送命令到Redis List</li>
                  <li>• 不等待任务完成</li>
                </ul>
              </div>
              <div class="bg-orange-50 border-l-4 border-orange-400 p-4 rounded">
                <h4 class="font-semibold text-orange-800 mb-3">
                  <i class="fas fa-database mr-2"></i>Job层：执行数据加载与缓存写入
                </h4>
                <p class="text-orange-700 text-sm mb-3">
                  <strong>Job层承担了缓存未命中时数据加载和缓存写入的核心职责</strong>
                  <a href="https://juejin.cn/post/7117530345569779726" class="citation">[59]</a>。
                </p>
                <ul class="text-orange-700 text-xs space-y-1">
                  <li>• 监听缓存填充队列</li>
                  <li>• 执行数据库查询</li>
                  <li>• 确定缓存键策略</li>
                  <li>• 写入Redis缓存</li>
                </ul>
              </div>
            </div>
          </div>

          <div id="avoiding-duplication">
            <h3 class="text-2xl font-semibold text-gray-800 mb-4">避免重复写入缓存的机制</h3>

            <div class="mb-6">
              <h4 class="text-xl font-semibold text-gray-800 mb-4">任务去重与幂等性处理</h4>
              <p class="text-gray-700 mb-4">
                在将缓存填充任务交由Job异步处理的改款设计中，一个潜在的问题是可能会发生重复的缓存写入操作，
                尤其是在高并发场景下或者消息队列出现某些异常时。
                <strong>为了避免这种情况，引入任务去重和幂等性处理机制至关重要</strong>。
              </p>

              <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-blue-50 border-l-4 border-blue-400 p-4 rounded">
                  <h5 class="font-semibold text-blue-800 mb-3">
                    <i class="fas fa-filter mr-2"></i>任务去重机制
                  </h5>
                  <ul class="text-blue-700 text-sm space-y-2">
                    <li>• <strong>唯一任务ID</strong>：由请求ID、数据标识符等组合生成</li>
                    <li>• <strong>临时去重存储</strong>：Redis键，设置较短过期时间</li>
                    <li>• <strong>检查机制</strong>：处理前检查ID是否已存在</li>
                    <li>• <strong>处理策略</strong>：已存在则丢弃或跳过</li>
                  </ul>
                </div>
                <div class="bg-purple-50 border-l-4 border-purple-400 p-4 rounded">
                  <h5 class="font-semibold text-purple-800 mb-3">
                    <i class="fas fa-redo mr-2"></i>幂等性处理
                  </h5>
                  <ul class="text-purple-700 text-sm space-y-2">
                    <li>• <strong>多次执行一致性</strong>：最终结果一致</li>
                    <li>• <strong>SET NX命令</strong>：仅在键不存在时设置</li>
                    <li>• <strong>版本号机制</strong>：避免旧数据覆盖新数据</li>
                    <li>• <strong>时间戳判断</strong>：确保数据最新性</li>
                  </ul>
                </div>
              </div>

              <div class="highlight-box mt-6">
                <h5 class="font-semibold text-gray-800 mb-3">实现要点</h5>
                <p class="text-gray-700 text-sm">
                  由于Service层在缓存未命中时会将请求转入Command流程，并通过消息队列通知Job处理
                  <a href="https://www.cnblogs.com/daxnet/p/8594287.html" class="citation">[60]</a>，
                  如果消息队列本身不保证Exactly-Once语义，那么Job层就需要实现幂等性逻辑来应对可能的重复消息。
                </p>
              </div>
            </div>

            <div>
              <h4 class="text-xl font-semibold text-gray-800 mb-4">通过Job统一管理缓存写入</h4>
              <p class="text-gray-700 mb-4">
                <strong>linkerlin/cqrs项目的小改款设计，其核心思想之一是通过将缓存填充任务完全交由Job层处理，
                  从而实现缓存写入逻辑的统一管理</strong>
                <a href="https://blog.csdn.net/yan_yu_lv_ji/article/details/128757837" class="citation">[62]</a>。
                这种设计从根本上避免了在Service层和Job层中重复编写缓存写入代码的问题。
              </p>

              <div class="diagram-container">
                <h5 class="font-semibold text-gray-800 mb-4 text-center">缓存写入统一管理</h5>
                <div class="mermaid-container">
                  <div class="mermaid-controls">
                    <button class="mermaid-control-btn zoom-in" title="放大">
                      <i class="fas fa-search-plus"></i>
                    </button>
                    <button class="mermaid-control-btn zoom-out" title="缩小">
                      <i class="fas fa-search-minus"></i>
                    </button>
                    <button class="mermaid-control-btn reset-zoom" title="重置">
                      <i class="fas fa-expand-arrows-alt"></i>
                    </button>
                    <button class="mermaid-control-btn fullscreen" title="全屏查看">
                      <i class="fas fa-expand"></i>
                    </button>
                  </div>
                  <div class="mermaid">
                    graph TB
                    subgraph &#34;传统设计&#34;
                    A1[&#34;Service层&#34;] --&gt; A2[&#34;写缓存逻辑&#34;]
                    B1[&#34;Job层&#34;] --&gt; B2[&#34;写缓存逻辑&#34;]
                    end

                    subgraph &#34;改款设计&#34;
                    C1[&#34;Service层&#34;] --&gt; C2[&#34;仅读缓存&#34;]
                    C1 --&gt; C3[&#34;触发任务&#34;]
                    D1[&#34;Job层&#34;] --&gt; D2[&#34;统一写缓存&#34;]
                    end

                    style A1 fill:#fecaca,stroke:#dc2626,stroke-width:2px,color:#374151
                    style A2 fill:#fecaca,stroke:#dc2626,stroke-width:2px,color:#374151
                    style B1 fill:#fecaca,stroke:#dc2626,stroke-width:2px,color:#374151
                    style B2 fill:#fecaca,stroke:#dc2626,stroke-width:2px,color:#374151
                    style C1 fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                    style C2 fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                    style C3 fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                    style D1 fill:#d1fae5,stroke:#10b981,stroke-width:2px,color:#374151
                    style D2 fill:#fef3c7,stroke:#f59e0b,stroke-width:2px,color:#374151
                  </div>
                </div>
              </div>

              <div class="bg-emerald-50 border-l-4 border-emerald-400 p-4 rounded mt-6">
                <h5 class="font-semibold text-emerald-800 mb-3">
                  <i class="fas fa-trophy mr-2"></i>统一管理的优势
                </h5>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h6 class="font-medium text-emerald-800 mb-2">技术优势：</h6>
                    <ul class="text-emerald-700 text-sm space-y-1">
                      <li>• 消除代码重复</li>
                      <li>• 集中缓存策略控制</li>
                      <li>• 简化维护和升级</li>
                      <li>• 统一监控和日志</li>
                    </ul>
                  </div>
                  <div>
                    <h6 class="font-medium text-emerald-800 mb-2">业务优势：</h6>
                    <ul class="text-emerald-700 text-sm space-y-1">
                      <li>• 提高系统可观察性</li>
                      <li>• 增强可维护性</li>
                      <li>• 便于缓存策略优化</li>
                      <li>• 降低错误风险</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>
    </main>

    <!-- Mobile TOC Toggle -->
    <button id="toc-toggle" class="fixed top-4 left-4 z-50 lg:hidden bg-white rounded-full p-3 shadow-lg">
      <i class="fas fa-bars text-gray-700"></i>
    </button>

    <script>
        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#0f766e',
                primaryTextColor: '#374151',
                primaryBorderColor: '#0f766e',
                lineColor: '#6b7280',
                secondaryColor: '#f3f4f6',
                tertiaryColor: '#ffffff',
                background: '#ffffff',
                mainBkg: '#ffffff',
                secondaryBkg: '#f9fafb',
                tertiaryBkg: '#f3f4f6',
                fontFamily: 'Inter, sans-serif',
                fontSize: '14px'
            },
            flowchart: {
                useMaxWidth: false,
                htmlLabels: true,
                curve: 'basis',
                padding: 20
            },
            sequence: {
                useMaxWidth: false,
                boxMargin: 10,
                boxTextMargin: 5,
                noteMargin: 10,
                messageMargin: 35
            },
            gantt: {
                useMaxWidth: false
            }
        });

        // Initialize Mermaid Controls for zoom and pan
        function initializeMermaidControls() {
            const containers = document.querySelectorAll('.mermaid-container');

            containers.forEach(container => {
            const mermaidElement = container.querySelector('.mermaid');
            let scale = 1;
            let isDragging = false;
            let startX, startY, translateX = 0, translateY = 0;

            // 触摸相关状态
            let isTouch = false;
            let touchStartTime = 0;
            let initialDistance = 0;
            let initialScale = 1;
            let isPinching = false;

            // Zoom controls
            const zoomInBtn = container.querySelector('.zoom-in');
            const zoomOutBtn = container.querySelector('.zoom-out');
            const resetBtn = container.querySelector('.reset-zoom');
            const fullscreenBtn = container.querySelector('.fullscreen');

            function updateTransform() {
                mermaidElement.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;

                if (scale > 1) {
                container.classList.add('zoomed');
                } else {
                container.classList.remove('zoomed');
                }

                mermaidElement.style.cursor = isDragging ? 'grabbing' : 'grab';
            }

            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                scale = Math.min(scale * 1.25, 4);
                updateTransform();
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                scale = Math.max(scale / 1.25, 0.3);
                if (scale <= 1) {
                    translateX = 0;
                    translateY = 0;
                }
                updateTransform();
                });
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                scale = 1;
                translateX = 0;
                translateY = 0;
                updateTransform();
                });
            }

            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', () => {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
                });
            }

            // Mouse Events
            mermaidElement.addEventListener('mousedown', (e) => {
                if (isTouch) return; // 如果是触摸设备，忽略鼠标事件

                isDragging = true;
                startX = e.clientX - translateX;
                startY = e.clientY - translateY;
                mermaidElement.style.cursor = 'grabbing';
                updateTransform();
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && !isTouch) {
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                updateTransform();
                }
            });

            document.addEventListener('mouseup', () => {
                if (isDragging && !isTouch) {
                isDragging = false;
                mermaidElement.style.cursor = 'grab';
                updateTransform();
                }
            });

            document.addEventListener('mouseleave', () => {
                if (isDragging && !isTouch) {
                isDragging = false;
                mermaidElement.style.cursor = 'grab';
                updateTransform();
                }
            });

            // 获取两点之间的距离
            function getTouchDistance(touch1, touch2) {
                return Math.hypot(
                touch2.clientX - touch1.clientX,
                touch2.clientY - touch1.clientY
                );
            }

            // Touch Events - 触摸事件处理
            mermaidElement.addEventListener('touchstart', (e) => {
                isTouch = true;
                touchStartTime = Date.now();

                if (e.touches.length === 1) {
                // 单指拖动
                isPinching = false;
                isDragging = true;

                const touch = e.touches[0];
                startX = touch.clientX - translateX;
                startY = touch.clientY - translateY;

                } else if (e.touches.length === 2) {
                // 双指缩放
                isPinching = true;
                isDragging = false;

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                initialDistance = getTouchDistance(touch1, touch2);
                initialScale = scale;
                }

                e.preventDefault();
            }, { passive: false });

            mermaidElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && isDragging && !isPinching) {
                // 单指拖动
                const touch = e.touches[0];
                translateX = touch.clientX - startX;
                translateY = touch.clientY - startY;
                updateTransform();

                } else if (e.touches.length === 2 && isPinching) {
                // 双指缩放
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = getTouchDistance(touch1, touch2);

                if (initialDistance > 0) {
                    const newScale = Math.min(Math.max(
                    initialScale * (currentDistance / initialDistance),
                    0.3
                    ), 4);
                    scale = newScale;
                    updateTransform();
                }
                }

                e.preventDefault();
            }, { passive: false });

            mermaidElement.addEventListener('touchend', (e) => {
                // 重置状态
                if (e.touches.length === 0) {
                isDragging = false;
                isPinching = false;
                initialDistance = 0;

                // 延迟重置isTouch，避免鼠标事件立即触发
                setTimeout(() => {
                    isTouch = false;
                }, 100);
                } else if (e.touches.length === 1 && isPinching) {
                // 从双指变为单指，切换为拖动模式
                isPinching = false;
                isDragging = true;

                const touch = e.touches[0];
                startX = touch.clientX - translateX;
                startY = touch.clientY - translateY;
                }

                updateTransform();
            });

            mermaidElement.addEventListener('touchcancel', (e) => {
                isDragging = false;
                isPinching = false;
                initialDistance = 0;

                setTimeout(() => {
                isTouch = false;
                }, 100);

                updateTransform();
            });

            // Enhanced wheel zoom with better center point handling
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.min(Math.max(scale * delta, 0.3), 4);

                // Adjust translation to zoom towards center
                if (newScale !== scale) {
                const scaleDiff = newScale / scale;
                translateX = translateX * scaleDiff;
                translateY = translateY * scaleDiff;
                scale = newScale;

                if (scale <= 1) {
                    translateX = 0;
                    translateY = 0;
                }

                updateTransform();
                }
            });

            // Initialize display
            updateTransform();
            });
        }

        // Initialize Mermaid controls after DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeMermaidControls();
        });

        // Mobile TOC Toggle
        const tocToggle = document.getElementById('toc-toggle');
        const tocFixed = document.querySelector('.toc-fixed');
        
        tocToggle?.addEventListener('click', () => {
            tocFixed.classList.toggle('open');
        });

        // Close TOC when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth < 1024 && tocFixed.classList.contains('open')) {
                if (!tocFixed.contains(e.target) && e.target !== tocToggle) {
                    tocFixed.classList.remove('open');
                }
            }
        });

        // Smooth scrolling for TOC links
        document.querySelectorAll('.toc-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
                
                // Close mobile TOC
                if (window.innerWidth < 1024) {
                    tocFixed.classList.remove('open');
                }
            });
        });

        // Active TOC link highlighting
        const observerOptions = {
            root: null,
            rootMargin: '-20% 0px -80% 0px',
            threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const id = entry.target.getAttribute('id');
                const tocLink = document.querySelector(`.toc-link[href="#${id}"]`);
                if (entry.isIntersecting) {
                    document.querySelectorAll('.toc-link').forEach(link => {
                        link.classList.remove('active');
                    });
                    tocLink?.classList.add('active');
                }
            });
        }, observerOptions);

        // Observe all sections
        document.querySelectorAll('section[id]').forEach(section => {
            observer.observe(section);
        });

        // Remove 'open' class on large screens
        window.addEventListener('resize', () => {
            if (window.innerWidth >= 1024) {
                tocFixed.classList.remove('open');
            }
        });
    </script>
  

</body></html>
